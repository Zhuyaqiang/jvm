# 二 自动内存管理

## 2 Java 内存区域与内存溢出异常

### 2.3 HotSpot 虚拟机对象解密

#### 2.3.3 对象的访问定位

* Java 程序通过栈上的 reference数据来操作堆上的具体对象. reference 类型是一个指向对象的引用, 访问方式主要有句柄和直接指针两种
  * 句柄: 堆中划分出一块内存来作为句柄池, reference 中存储的是对象的句柄地址, 句柄中包含了对象实例数据与类型数据各自具体的地址信息. 优点时 reference 中存储的是稳定句柄地址, 在对象被移动时只会改变句柄中的实例数据指针, 而 reference 本身不需要被修改
  * 直接指针: reference 中存储的时对象地址, 优点是如果只访问对象本身, 就可以节约一次间接访问的开销

### 2.4 实战: OutOfMemoryError 异常

#### 2.4.1 Java 堆溢出

* 不断创建对象, 且保证 GC Roots 到对象之间有可达路径来避免垃圾回收清除对象, 总容量到达最大堆的容量之后就会产生该异常

* 通过-Xms20m(最小值) -Xmx20m(最大值)两个参数将堆大小设置成不可扩展

  ```java
  public class HeapOOM {
      static class OOMObject{}
      public static void main(String[] args) {
          List<OOMObject> list = new ArrayList<>();
          while (true)
              list.add(new OOMObject());
      }
  }
  ```

  

#### 2.4.2 虚拟机栈和本地方法栈溢出

* HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈, -Xoss 参数(设置本地方法栈)无效, 只能用-Xss 参数来设定

* 两种异常:

  * 线程请求的栈深度大于虚拟机所允许的最大深度, 抛出StackOverflowError
  * 虚拟机的栈允许动态扩展, 但是扩展栈容量无法申请到足够的内存, 抛出OutOfMemory异常

* HotSpot 不允许动态扩展栈, 因此只可能在创建线程时申请内存失败出现 OutOfMemory 异常

* StackOverflowError 异常:

  * 使用-Xss 参数减少栈内存容量, 使用-Xss128k 限制虚拟机栈内存后堆栈深度由18000+减至700+

    ```java
    public class JavaVMStackSOF {
        private int stackLength = 1;
        public void stackLeak() {
            stackLength++;
            stackLeak();
        }
        public static void main(String[] args) {
            JavaVMStackSOF oom = new JavaVMStackSOF();
            try {
                oom.stackLeak();
            } catch (Throwable e) {
                System.out.println("stack length: " + oom.stackLength);
                throw e;
            }
        }
    }
    ```

    

  * 定义大量的本地变量, 增大方法帧中本地变量表的长度

    ```java
    public class JavaVMStackSOF2 {
        private static int stackLength = 0;
        public static void test() {
            long[] unused = new long[100];
            stackLength ++;
            test();
            unused[0] = 0;
            for (int i = 1; i < 100; i++)
                unused[i] = unused[0] = 0;
        }
        public static void main(String[] args) {
            try {
                test();
            } catch (Error e) {
                System.out.println("stack length: " + stackLength);
                throw e;
            }
        }
    }
    ```

  * 创建线程导致的 OOM 异常: 和栈空间是否足够无关, 主要取决于系统本身的内存使用状态

#### 2.4.3 方法区和运行时常量池溢出

* 运行时常量池时方法区的一部分

* String::intern()时本地方法, 检查如果字符串常量池中包含一个等于此 String 对象的字符串, 则返回该字符串 String 对象的引用, 否则将此 String 对象包含的字符串添加到常量池中. JDK7之前通过-XX: PermSize 和-XX: MaxPermSize 限制永久代大小(常量池分配在永久代中), JDK7及之后原本存放在永久代的字符被移至 Java 堆中, 因此通过-Xmx 参数限制最大堆
* 方法区主要用于存放类型的相关信息

#### 2.4.4 本机直接内存溢出

* 直接内存的容量大小通过-XX: MaxDirectMemorySize 参数指定, 默认与 Java 堆的最大值(-Xmx 指定)一致
* 直接内存溢出的特征: 在 Heap Dump 文件中不会看见明显的异常, 程序中直接或间接使用 DirectMemory

## 3 垃圾收集器与内存分配策略

### 3.1 概述

* 程序计数器, 虚拟机栈, 本地方法栈随线程的生命周期而生死, 因此这几个区域的内存分配和回收都具备确定性, 当放发结束或者线程结束时, 内存便跟着被回收了
* Java 堆和方法区有显著的不确定性, 这部分内存的分配和回收时动态的.

### 3.2 对象已死? 

#### 3.2.1 引用器记数法

* 在对象中添加一个引用计数器, 每当被引用一次, 计数器值就加一; 引用失效时, 计数器值就减一. 原理简单
* 但是引用计数器很难解决对象之间相互循环引用的问题, 所以主流的 Java 虚拟机没有选用该方式来管理内存

#### 3.2.2 可达性分析算法

* 以一系列称为 GC Roots 的根对象作为起始节点集, 从根节点开始, 根据引用关系向下搜索, 如果某个对象到 GC Roots 间没有任何引用链相连(GC Roots 到这个对象不可达)
* 可作为 GC Roots 的对象:
  * 在虚拟机栈中引用的对象(栈帧中的本地变量表)
  * 在方法区中类静态属性引用的对象
  * 在方法区中常量引用的对象, 如字符串常量池里的引用
  * 本地方法栈中 Native 方法引用的对象
  * Java 虚拟机内部的引用
  * 所有被同步锁持有的对象
  * 反映 Java 虚拟机内部情况的 JMXBean, JVMTI 中注册的回调和本地代码缓存等
  * 根据用户所选的垃圾收集器一级当前回收的内存区域, 可能有其他临时加入的对象

#### 3.2.3 再谈引用

* JDK1.2后堆引用的扩充:
  * 强引用: 最传统的引用, 普遍存在的引用赋值. 强引用关系存在, 垃圾收集器一定不会回收被引用的对象
  * 软引用: 用来描述一些还有用, 但非必须的对象. 在内存溢出异常前, 会把这些对象进行二次回收, 如果这次内存还不够, 则抛出内存溢出的异常
  * 弱引用: 强度比软引用更弱, 被弱引用关联的对象只能生存到下一次垃圾收集发生
  * 虚引用: 最弱的引用, 不对垃圾收集和对象生存时间构成影响, 只是为了在这个对象被回收时收到系统通知

#### 3.2.4 生存还是死亡?

* 宣告对象死亡的两步: ①可达性分析后发现没有与 GC Roots 相连的引用链, 第一次标记. ②筛选是否需要执行 finalize()方法, 如果对象没有覆盖过 finalize()方法或者 finalize()方法已经被虚拟机调用过, 则不执行回收
* 注: finalize()方法只会被系统自动调用一次

#### 3.2.5 回收方法区

* 方法区回收的两部分内容:
  * 废弃的常量
  * 不再使用的类型

### 3.3 垃圾收集算法

#### 3.3.1分代收集理论

* 分代收集理论建立在两个分代假说之上:
  * 弱分代假说: 绝大多数对象都是朝生夕灭的
  * 强分代假说: 熬过越多次垃圾收集过程的对象就越难消亡
* 第三个假说跨代引用假说: 跨代引用相对于同代引用来说仅占极少数.该假说为两个分代假说的隐含结论
* 在新生代上简历全局数据结构记忆集, 把老年带分成若干小块, 标识出存在跨代引用的老年带, 发生 MinorGC 时只有包含了跨代引用的内存的对象才会被加入到 GC Root
* 收集的类型
  1. 部分收集(Partial GC)
     1. 新生代收集(Minor GC/Young GC)
     2. 老年带收集(Major GC/Old GC)
     3. 混合收集(Mixed GC)
  2. 整堆收集(Full GC)

#### 3.3.2 标记-清除算法

* 最基础的收集算法, 缺点: ①执行效率不稳定, 若 Java 堆中有大量需要回收的对象,则需要进行大量的标记和清除动作②会产生大量不连续的内存碎片

#### 3.3.3 标记-复制算法

* 为了解决标记-清除算法 **执行效率低** 的问题
* 半区复制
  * 将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块, 使用的这块用完之后, 将还存获得对象复制到另一块上
  * 缺点: 对于大量存活对象的情况, 会产生大量复制开销, 且可用内存缩小了一半
* Appel 式回收
  * 把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间, 每次分配内存只使用 Eden 和一块 Survivor, 发生垃圾收集时, 将 Eden 和 Survivor 中仍存活的对象复制到另一块 Survivor 上, 再清理 Eden 和用过的 Survivor
  * HotSpot 默认 Eden 和 Survivor 大小比例是8:1
  * 当 Survivor 不够存放存活对象时, 需要依赖其他区域(大多数是老年代)进行分配担保

#### 3.3.4 标记-整理算法

* 针对老年代对象的存亡特征提出的标记-整理算法, 让存活的对象向内存空间一端移动, 然后清理掉边界以外的内存
* 移动对象内存回收时会更复杂, 但是吞吐量大; 不移动对象内存分配时会更复杂, 但停顿时间短, 甚至不需要停顿, 延迟低

### 3.4 HotSpot 的算法细节实现

#### 3.4.1 根节点枚举

* 迄今为止, 所有收集器的根节点枚举必须暂停拥护线程, 保证分析过程中根节点集合的对象引用关系不发生变化
* HotSpot 中使用一组成为 OopMap 的数据结构来记录哪些地方存在对象引用, 而不需要一个不漏地从方法区等 GC Roots 开始查找

#### 3.4.2 安全点

* 如果为每一条指令都生成对应的 OopMap, 则会需要大量的额外存储空间. 因此只在"特定的位置"记录了这些信息, 这些位置被称为 **安全点**. 用户程序执行时被强制要求必须到达安全点后才能够暂停
* 安全点位置的选取基本上以 **是否具有让程序长时间执行的特征** 为标准选定的. 这个长时间执行最明显的特征是指令序列的复用, 如方法跳转, 循环跳转, 异常跳转等(因为每条指令执行的时间都非常短暂, 因此不会因为指令流程长度太长的原因长时间执行)
* 如何再垃圾收集发生时让所有线程都跑到安全点:
  * 抢先式中断: 垃圾收集发生时系统强制中断所有拥护线程, 如果发现有拥护线程中断的地方不在安全点, 就恢复这条线程执行, 让它一会再中断, 直到跑到安全点. **使用少**
  * 主动式中断: 垃圾收集发生时系统仅仅简单地设置一个标志位, 各个线程执行过程中不断轮询标志位, 一旦发现需要中断时就在离自己最近的安全点上主动中断挂起. 

#### 3.4.3 安全区域

* 为了解决程序不执行时(Sleep 或 Blocked状态下, 无法响应中断请求, 不能走到安全的地方中断挂起)的中断问题, 引入安全区域
* 安全区域指能够确保某一段代码片段中引用关系不会发生变化, 在这个区域任意地方开始垃圾收集都是安全的
* 进入安全区域的线程会标识自己进入了安全区域, 虚拟机发起垃圾收集时就可以不管已声明在安全区域内的线程. 若要离开安全区域时根节点枚举未结束则会等待到根节点枚举结束

#### 3.4.5 记忆集与卡表

* 所有涉及部分区域收集行为的垃圾收集器都可能面临跨代引用问题
* 记忆集是一种 **用于记录从非收集区指向收集区域的指针集合的抽象数据结构**. 

* 垃圾收集的场景中, 收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针, 不需要了解跨代引用的全部细节, 因此可以选择相对(用非收集区**所有**含跨代引用的**对象数组**实现)更粗犷的记录粒度来节省记忆集的存储和维护成本:
  * 字节精度: 每个记录精确到一个机器字长(即处理器的寻址位数), 该字包含跨代指针
  * 对象精度: 每个记录精确到一个对象, 该对象里有字段包含跨代指针
  * 卡精度: 每个记录精确到一块内存区域, 该区域内有对象含有跨代指针. 被称为卡表方式, 是最常用的记忆集实现形式
* 卡表最简单的形式可以是一个字节数组, 其中每个元素都对硬着其标识的内存区域中一块特定大小的内存块, 被称作"卡页". 一个卡页的内存中通常包含不止一个对象, 只要卡页内有一个及以上的对象字段存在跨代指针, 就将对应卡表的数组元素标识为1, 没有则标识为0. 垃圾收集发生时, 将标识为1的元素加入 GC Roots 一并扫描

#### 3.4.5 写屏障

* 必须找到一个在机器码层面的手段, 把维护卡表的动作放到每一个赋值操作之中. HotSpot 中使用 **写屏障** 实现
* 写屏障可以看作是引用对象赋值动作的 AOP 切面, 会产生一个环形通知, 供程序执行额外的操作. (增加更新卡表操作, 一般用于写后屏障)
* 伪共享: 不同卡表元素对应的内存区域可能位于同一个缓存行中, 不同现车给你同时更新时会影响性能. 解决方案是不采用无条件的写屏障, 先检查卡表标记, 只有当该卡表元素未被标记过才将其标记.

#### 3.4.6 并发的可达性分析

* 并发时可能出现的不好情况: 把原本消亡的对象标记为存活/把原本存活的对象标记为消亡
* 为了解决以上的情况, 有两种解决方案
  1. 增量更新: 以扫描完成的对象插入新的指向未扫描对象的引用关系时, 将这个新插入记录下来, 等并发扫描结束后, 再将记录过的引用关系的对象作为扫描根进行扫描
  2. 原始快照: 当扫描过(但未扫描完)的对象要删除指向未扫描对象的引用关系时, 将这个要删除的引用记录下来, 并发扫描结束后, 将记录过的引用关系的对象作为扫描根, 重新扫描一次

### 3.5 经典垃圾收集器

#### 3.5.1 Serial 收集器

* 单线程工作, 即垃圾收集时必须暂停其他所有工作线程, 新生代标记-复制, 老年代标记-整理
* HotSpot 运行在客户端模式的默认新生代收集器, 简单而高效(相对其他收集器的单线程)

#### 3.5.2 ParNew 收集器

* Serial 收集器的多线程并行版本
* 除了 Serial 收集器外只有 ParNew 收集器能和 CMS 收集器配合工作

#### 3.5.3 Parallel Scavenge 收集器

* 新生代收集器, 基于标记-复制算法
* 关注点和其他收集器不同, 达到可控制的吞吐量
* -XX: MaxGCPauseMillis 参数设置最大垃圾收集停顿时间(尽量满足), 停顿时间下降会导致吞吐量下降
* -XX: GCTimeRatio 参数设置垃圾垃圾收集时间占总时间比例的倒数, 默认99-> 占比允许1%的垃圾收集时间
* -XX: UseAdaptiveSizePolicy, 激活后就不需要人工指定新生代大小(-Xmn), Eden 与 Survivor 区的比例(-XX: SurvivorRatio), 晋升老年代对象的大小(-XX: PretenureSizeThreshold)等细节参数, 被称为垃圾收集的自适应调节策略. 使用该策略时只需要基本的内存数据设置好, 如-Xmx 最大堆, -XX: MaxGCPauseMillis(更关注停顿时间) 或-XX: GCTimeRatio(更关注吞吐量)

#### 3.5.4 Serial Old 收集器

* Serial 收集器的老年代版本, 使用标记-整理算法
* 服务端模式下的两种用途:
  * JDK5及之前, 与 Parallel Scavenge 收集器搭配使用
  * 作为 CMS 收集器发生失败时的后背元

#### 3.5.5 Parallel Old 收集器

* 是 Parallel Scavenge 收集器的老年代岸本, 基于标记整理算法
* 和 Parallel Scavenge 收集器搭配成为吞吐量优先的收集器组合

#### 3.5.6 CMS 收集器

* 关注**最短回收停顿时间**, 主要用于 B/S 系统的服务端, 基于标记-清除
* 初始标记-并发标记-重新标记-并发清除
  * 初始标记: 仅标记GC Roots能直接关联到的对象, 需暂停所有用户线程
  * 并发标记: 从初始标记对象开始遍历所有对象, 不需要暂停用户线程
  * 重新标记: 修正并发标记期间变动的对象, 需要暂停所有用户线程
  * 并发清除, 可与用户线程并发
* 三个缺点:
  1. 对处理器资源非常敏感, 当处理器核心不足四个时, CMS对用户程序的影响可能变大. 一种优化方案: 增量式并发收集器, 在并发标记和并发清理的时候让垃圾收集线程和用户线程交替运行, 结果是速度变慢的时见多了但是速度变慢的幅度小了
  2. 无法收集浮动垃圾, 可能出现Con-current Mode Failure导致暂停用户线程的Full GC. (浮动垃圾: 并发标记和并发清理阶段用户线程运行时产生的垃圾). 因为需要用户线程并发, 因此还需要预留一部分老年代空间给用户线程
  3. 因为基于标记-清除, 因此可能产生很多的空间碎片

#### 3.5.7 Garbage First 收集器

* G1收集器, 开创了面向局部收集的设计思路和基于Region的内存布局形式.
* Mixed GC模式: 不再单纯回收老年代/新生代/整个Java堆, 而是根据哪块内存中垃圾最多, 回收收益最大来进行回收
* 把Java堆划分成多个大小相等的独立区域(Region), 每个Region都可以根据需要扮演新生代的Eden空间或Survivor空间或是老年代空间, 将Region作为垃圾回收的最小单元, 优先回收价值高的Region
* 需要解决的问题
  * 跨Region引用: 记忆集
  * 收集线程和用户线程互不影响: 采用原始快照的方式. 除此之外, 每个Region还维护两个名为TAMS的指针, 在并发回收过程中新分配的对象地址都应该在这两个指针之上
  * 建立可靠的停顿预测模型: 以衰减均值为理论基础来实现, 能更准确的代表**最近**的平均状态
* 流程: 
  * 初始标记: 仅标记GC Roots直接关联的对象, 修改TAMS保证并发过程中可以正确分配新对象
  * 并发标记: 进行可达性分析
  * 最终标记: 短暂暂停用户线程, 用于处理并发标记阶段遗留下来的少量SATB记录
  * 筛选回收: 对各个Region进行排序, 根据用户期望的停顿时间制定回收计划, 必须暂停用户线程
* 从整体看, 基于标记-整理算法, 根据用户设定的**期望停顿时间**在不同场景下获得关注吞吐量和关注延迟之间的平衡
* 相比于CMS的缺点:
  * 由于卡表实现更为复杂, 且每个Region无论是新生代还是老年代, 都需要一份卡表, 导致**内存占用**高
  * CMS的写后屏障是直接的同步操作, G1的写后屏障类似于消息队列, 再做异步处理, 因此执行负载较高

### 3.6 低延迟垃圾收集器

* 内存的扩大对垃圾收集器的延迟会带来负面影响
* Shenandoah和ZGC几乎整个工作过程全部都是并发的

#### 3.6.1 Shenandoah收集器

* 和G1有相似的堆内存布局, 多阶段的处理思路上高度一致
* 与G1的不同:
  * G1回收阶段可以多线程并行, 但是不能与用户线程并发, Shenandoah收集器可以
  * Shenandoah目前默认不使用分代收集
  * Shenandoah摒弃了记忆集, 改用名为**连接矩阵**的数据结构来记录跨Region的引用关系
* 工作过程中的九个阶段
  * 初始标记: 标记和GC Roots直接关联的对象
  * **并发标记**: 遍历对象图, 标记出全部可达对象
  * 最终标记: 处理剩余的SATB扫描, 统计回收价值最高的Region, 构成回收集. 该阶段会有一小段短暂的停顿
  * 并发清理: 清理整个区域内一个存活对象都没有找到的Region
  * **并发回收**: 把要回收集里的存活对象复制一份到其他未被使用的Region中, 通过读屏障和"Brook Pointers"(转发指针)来实现
  * 初始引用更新: 建立线程集合点, 确保并发回收的线程已完成对象移动, 会有短暂的停顿
  * **并发引用更新**: 把堆中指向旧对象的引用修正到复制后的新地址. 按照内存物理地址顺序, 线性搜索出引用类型, 修改值
  * 最终引用更新: 修改存在于GC Roots中的引用, 是最后一次停顿
  * 并发清理: 清理回收集中剩下的Region
* 转发指针
  * 原有的实现对象移动与用户程序并发的方案是设置**保护陷阱**, 一旦用户程序访问到属于旧对象原有的内存旧自毁中断, 再在预设号的异常处理器中将访问呢转发到新对象上.
  * 在原有对象布局结构的最前面统一增加一个新的引用字段, 在正常不处于并发移动的情况下, 该引用指向对象自己
  * 必须对转发指针的操作采取同步措施, 让收集器线程或用户线程对转发指针的访问只有一个能成功. 通过比较并交换(CAS)操作来保证并发时对象的访问正确性
* 在读写屏障中都加入了额外的转发处理

#### 3.6.2 ZGC收集器

* 基于Region的堆内存布局, (暂时)不设分代, Region具有动态性: 动态创建和销毁, 动态的区域容量大小
* Region的三种容量
  * 小型Region: 2MB, 放置小于256KB的小对象
  * 中型Region: 32MB, 放置大于等于256KB但小于4MB的对象
  * 大型Region: 容量不固定, 必须是2MB的整倍数, 用于放置4MB以上的对象. **每个大型Region只会存放一个大对象**
* 并发整理算法的实现通过染色指针
* 染色指针是一种直接将少量额外的信息存储在指针上的技术(linux系统下46位指针的高4位)
* 染色指针优点: 
  * 一旦某个Region的存活对象被移走之后, 这个Region立即被释放和重用, 不需要等待整个堆中所有指向该Region的引用都被修正
  * 大幅减少在垃圾收集过程中内存屏障的是用数量
  * 可作为一种可扩展的存储结构用来记录更多与对象标记, 重定位过程相关的数据
* 四个阶段:
  * 并发标记: 遍历对象图做可达性分析
  * 并发预备重分配: 根据特定的查询条件统计得出本次收集过程要清理的Region, 组成重分配集
  * **并发重分配**: 把重分配集中的存活对象复制到新的Region上, 并为重分配集中的每个Region维护一个转发表. 记录旧对象到新对象的转向关系. 由于染色指针的支持, 收集器能仅从引用上就明确得知一个对象是否处于重分配集中, 因此如果用户线程访问了位于重分配集中的对象, 会被内存屏障截获, 然后转发到新的对象上, 同时修正引用的值.
  * 并发重映射: 修正整个堆中指向重分配集中旧对象的锁有引用, 因为旧引用可以自愈, 所以这个阶段的工作合并到了下一次垃圾收集循环中的并发标记阶段

### 3.7 选择合适的垃圾收集器

#### 3.7.1 Epslion收集器

* 不进行垃圾收集: 面向运行数分钟甚至数秒的应用, 只要Java虚拟机能够正确分配内存, 在堆耗尽之前就会退出

#### 3.7.2 收集器的权衡

* 应用程序的关注点:
  * 数据分析/科学计算类的任务, 目标时快速出结果, 应该关注吞吐量
  * SLA应用, 关注延迟/停顿时间
  * 客户端或嵌入式应用, 关注垃圾收集的内存占用
* 运行应用的基础设施
* 使用JDK 的发行商, 版本号

#### 3.7.3 虚拟机及垃圾收集器日志

### 3.8 实战: 内存分配与回收策略

#### 3.8.1 对象优先在Eden分配

* 大多数情况下, 对象在新生代Eden区中分配. 当Eden区中没有足够空间进行分配时, 虚拟机将发起Minor GC, 通过分配担保机制将之前新生代中的对象转移到老年代

#### 3.8.2 大对象直接进入老年代

* Java虚拟机中要避免大对象是因为在分配空间时容易导致因没有**连续**内存空间而引发的垃圾收集
* -XX: PretenureSizeThreshold参数制定大与该设置值的对象直接在老年代分配, 避免在Eden区及两个Survivor区之间来回复制

#### 3.8.3 长期存活的对象将进入老年代

* 经过第一次MinorGC后仍然存活且能被Survivor容纳的对象会被移动到Survivor空间中, 且每熬过一次MinorGC, 年龄就增加1岁, 达到阈值后晋升到老年代(默认15). 通过参数-XX: MaxTenuringThresshold设置阈值

#### 3.8.4 动态对象年龄判定

* Survivor空间中相同年龄所有对象大小总和大与Survivor空间的一半, 年龄大于或等于该对象的年龄可以直接进入老年代

#### 3.8.5 空间分配担保

* MinorGC之前, 检查老年代最大可用的连续空间是否大与新生代所有对象总空间, 成立则这次MinorGC确保是安全的(当Survivor中无法容纳新生代的存活对象时, 需要老年代进行分配担保). 分配担保的前提是**老年代能容纳这些对象**. 
* 如果不能确保MinorGC是安全的, 则检查-XX: HandlePromotionFailure参数设置是否允许担保失败. 如果允许会继续检查老年代最大可用的连续空间是否大与历次晋升到老年代对象的平均大小, 如果大于则尝试进行MinorGC, 如果小于或不允许冒险, 则需要进行FullGC

## 4 虚拟机性能监控, 故障处理工具

### 4.1 概述

* 处理数据: 异常堆栈, 虚拟机运行日志, 垃圾收集器日志, 线程快照(threaddump/javacore文件), 堆转储快照(heapdump/hprof文件)等

### 4.2 基础故障处理工具

#### 4.2.1 jps: 虚拟机进程状况工具

* JVM Process Status Tool, 列出正在运行的虚拟机进程及其本地虚拟机唯一ID(**LVMID**, Local Virtual Machine Identifier)

#### 4.2.2 jstat: 虚拟机统计信息监视工具

* JVM Statistics Monitoring Tool, 用于监视虚拟机各种运行状态信息的工具
* `jstat -gc 2764 250 20`每隔250ms查询一次进程2764的垃圾收集情况, 一共查询20次
* `jstat -gcutil 2764` 

#### 4.2.3 jinfo: Java配置信息工具

* 实时查看和调整虚拟机各项参数

## 5 调优案例分析与实战

### 5.2 案例分析

#### 5.2.1 大内存硬件上的程序部署策略

* 单个Java虚拟机实例管理大内存可能面临的问题:
  * 回收大块堆内存而导致的长时间停顿. G1有所环节, ZGC和Shenandoah成熟之后能解决
  * 大内存必须有64位Java虚拟机的支持, 由于指针压缩, 处理器缓存行等问题, 性能普遍低于同版本32位虚拟机
  * 必须保证应用程序足够问题, 否则大型单体应用发生堆内存溢出难以分析
  * 相同程序在64位虚拟机中消耗的内存一般比32位虚拟机大, 可以通过压缩指针环节
* 同时使用若干个虚拟机建立逻辑机群来利用硬件资源, 目的仅仅是尽可能利用硬件资源, 不需要保证每个虚拟机进程有绝对的负载均衡, 因此试用无Session复制的亲和式机群是相当合适的. 可能存在的问题:
  * 节点竞争全局资源
  * 很难高效率地利用某些资源池, 因为各个节点一般都建立子集独立的资源池
  * 大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费

#### 5.2.2 集群间同步导致的内存溢出

#### 5.2.3 堆外内存导致的溢出错误

* Direct Memory耗用的内存不计算在堆之内, 如果虚拟机打开了-XX: +DisableExplicitGC开关, 禁止了人工出发垃圾收集, 就会导致堆中还有空闲内存却不得不抛出内存溢出异常

* 小内存会32位应用时, 除了Java堆和方法区外, 还应该关注:

  1. 直接内存: 通过-XX: MaxDirectMemorySize调整大小, 不足时抛出OutOf-MemoryError或OutOfMemoryError: Direct buffer memory
  2. 线程堆栈: 通过-Xss调整大小, 内存不足时抛出StackOerflowError或OutOfMemoryError
  3. Socket缓存区: 每个Socket链接都有Receive和Send两个缓存区, 链接多的话也可能出问题, 抛出IOException: Too many open files
  4. JNI代码
  5. 虚拟机和垃圾收集器

  这些内存和Java堆以及方法区**总和**受到操作系统进程最大内存的限制

#### 5.2.4 外部命令导致系统缓慢

#### 5.2.5 服务器虚拟机进程崩溃

#### 5.2.6 不恰当的数据结构导致内存占用过大

#### 5.2.7 由Windows虚拟内存导致的长时间停顿

#### 5.2.8 由安全点导致长时间停顿

# 三 虚拟机执行子系统

## 6 类文件结构

### 6.2 无关性的基石

* 字节码文件

### 6.3 Class类文件的结构

* 任何一个class文件都对应着唯一的一个类或接口的定义信息, 但是类或接口不一定都得定义在文件里, 也可以动态生成
* Class文件格式采用一种类似于C语言结构体的伪结构来存储数据, 这种伪结构只有两种数据结构:
  * 无符号数: 以u1, u2, u4, u8分别代表1个字节, 2个字节, 4个字节和8个字节的无符号数
  * 表: 多个无符号数或者其他表作为数据项构成的复合数据类型
* 需要描述同一类型但数量不定的多个数据时, 会使用一个前置的容量计数器加若干个连续的数据向的形式, 称为集合

#### 6.3.1 魔数与Class文件的版本

* 每个Class文件的头4个字节, 唯一作用是确定这个文件是否是一个能被虚拟机接受的Class文件. (0xCAFEBABE)
* 接下来4个字节存储的是Class文件的版本号, 前两个字节是次版本号, 后两个字节是主版本号

#### 6.3.2 常量池

* 紧接着版本号的是常量池入口, 放置一项u2类型的数据, 代表常量池容量计数器(constant_pool_count), **从1开始**不是从0开始(值为20代表常量池中有19项常量, 索引范围1-19), 0索引的作用是表达后面某些指向常量池的索引值的数据在特定情况下表示**不引用任何一个常量池项目**

* 常量池中存放的两大类常量: 

  * 字面量: 文本字符串, 被声明为final的常量值等

  * 符号引用: 编译原理方面的概念, 主要包括

    1. 被模块导出或开放的包
    2. 类和接口的全限定名
    3. 字段的名称和描述符
    4. 方法的名称和描述符
    5. 方法句柄和方法类型

    Javac编译时在虚拟机家在Class文件时进行动态连接, 因此Class文件中不会保存各个方法, 字段最终在内存中的布局. 虚拟机做类加载时, 会从常量池获得对应的符号引用, 再在类创建时或运行时解析, 翻译到具体的内存地址中

* 常量池中每一项常量都是一个表(共17项), 每个表结构起始的第一位是一个u1类型的标志位, 标志当前常量类型, 第二位是u2类型的name_index时常量池的索引值, 指向代表这个类(或者接口的)全限定名

* javap工具: `javap -verbose TestClass`可以输出TestClass.class文件字节码内容

#### 6.3.3 访问标志

* 常量池结束之后, 紧接着的2个字节代表访问标志, 用于识别一些类或者接口层次的访问信息: Class是类还是接口, 是否public, 是否abstract, 是否final. 这个值是由"是"标志含义的标志值的位或运算获得的.

#### 6.3.4 类索引, 父类索引与接口索引集合