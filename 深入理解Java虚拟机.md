# 二 自动内存管理

## 2 Java 内存区域与内存溢出异常

### 2.3 HotSpot 虚拟机对象解密

#### 2.3.3 对象的访问定位

* Java 程序通过栈上的 reference数据来操作堆上的具体对象. reference 类型是一个指向对象的引用, 访问方式主要有句柄和直接指针两种
  * 句柄: 堆中划分出一块内存来作为句柄池, reference 中存储的是对象的句柄地址, 句柄中包含了对象实例数据与类型数据各自具体的地址信息. 优点时 reference 中存储的是稳定句柄地址, 在对象被移动时只会改变句柄中的实例数据指针, 而 reference 本身不需要被修改
  * 直接指针: reference 中存储的时对象地址, 优点是如果只访问对象本身, 就可以节约一次间接访问的开销

### 2.4 实战: OutOfMemoryError 异常

#### 2.4.1 Java 堆溢出

* 不断创建对象, 且保证 GC Roots 到对象之间有可达路径来避免垃圾回收清除对象, 总容量到达最大堆的容量之后就会产生该异常

* 通过-Xms20m(最小值) -Xmx20m(最大值)两个参数将堆大小设置成不可扩展

  ```java
  public class HeapOOM {
      static class OOMObject{}
      public static void main(String[] args) {
          List<OOMObject> list = new ArrayList<>();
          while (true)
              list.add(new OOMObject());
      }
  }
  ```

  

#### 2.4.2 虚拟机栈和本地方法栈溢出

* HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈, -Xoss 参数(设置本地方法栈)无效, 只能用-Xss 参数来设定

* 两种异常:

  * 线程请求的栈深度大于虚拟机所允许的最大深度, 抛出StackOverflowError
  * 虚拟机的栈允许动态扩展, 但是扩展栈容量无法申请到足够的内存, 抛出OutOfMemory异常

* HotSpot 不允许动态扩展栈, 因此只可能在创建线程时申请内存失败出现 OutOfMemory 异常

* StackOverflowError 异常:

  * 使用-Xss 参数减少栈内存容量, 使用-Xss128k 限制虚拟机栈内存后堆栈深度由18000+减至700+

    ```java
    public class JavaVMStackSOF {
        private int stackLength = 1;
        public void stackLeak() {
            stackLength++;
            stackLeak();
        }
        public static void main(String[] args) {
            JavaVMStackSOF oom = new JavaVMStackSOF();
            try {
                oom.stackLeak();
            } catch (Throwable e) {
                System.out.println("stack length: " + oom.stackLength);
                throw e;
            }
        }
    }
    ```

    

  * 定义大量的本地变量, 增大方法帧中本地变量表的长度

    ```java
    public class JavaVMStackSOF2 {
        private static int stackLength = 0;
        public static void test() {
            long[] unused = new long[100];
            stackLength ++;
            test();
            unused[0] = 0;
            for (int i = 1; i < 100; i++)
                unused[i] = unused[0] = 0;
        }
        public static void main(String[] args) {
            try {
                test();
            } catch (Error e) {
                System.out.println("stack length: " + stackLength);
                throw e;
            }
        }
    }
    ```

  * 创建线程导致的 OOM 异常: 和栈空间是否足够无关, 主要取决于系统本身的内存使用状态

#### 2.4.3 方法区和运行时常量池溢出

* 运行时常量池时方法区的一部分

* String::intern()时本地方法, 检查如果字符串常量池中包含一个等于此 String 对象的字符串, 则返回该字符串 String 对象的引用, 否则将此 String 对象包含的字符串添加到常量池中. JDK7之前通过-XX: PermSize 和-XX: MaxPermSize 限制永久代大小(常量池分配在永久代中), JDK7及之后原本存放在永久代的字符被移至 Java 堆中, 因此通过-Xmx 参数限制最大堆
* 方法区主要用于存放类型的相关信息

#### 2.4.4 本机直接内存溢出

* 直接内存的容量大小通过-XX: MaxDirectMemorySize 参数指定, 默认与 Java 堆的最大值(-Xmx 指定)一致
* 直接内存溢出的特征: 在 Heap Dump 文件中不会看见明显的异常, 程序中直接或间接使用 DirectMemory

## 3 垃圾收集器与内存分配策略

### 3.1 概述

* 程序计数器, 虚拟机栈, 本地方法栈随线程的生命周期而生死, 因此这几个区域的内存分配和回收都具备确定性, 当放发结束或者线程结束时, 内存便跟着被回收了
* Java 堆和方法区有显著的不确定性, 这部分内存的分配和回收时动态的.

### 3.2 对象已死? 

#### 3.2.1 引用器记数法

* 在对象中添加一个引用计数器, 每当被引用一次, 计数器值就加一; 引用失效时, 计数器值就减一. 原理简单
* 但是引用计数器很难解决对象之间相互循环引用的问题, 所以主流的 Java 虚拟机没有选用该方式来管理内存

#### 3.2.2 可达性分析算法

* 以一系列称为 GC Roots 的根对象作为起始节点集, 从根节点开始, 根据引用关系向下搜索, 如果某个对象到 GC Roots 间没有任何引用链相连(GC Roots 到这个对象不可达)
* 可作为 GC Roots 的对象:
  * 在虚拟机栈中引用的对象(栈帧中的本地变量表)
  * 在方法区中类静态属性引用的对象
  * 在方法区中常量引用的对象, 如字符串常量池里的引用
  * 本地方法栈中 Native 方法引用的对象
  * Java 虚拟机内部的引用
  * 所有被同步锁持有的对象
  * 反映 Java 虚拟机内部情况的 JMXBean, JVMTI 中注册的回调和本地代码缓存等
  * 根据用户所选的垃圾收集器一级当前回收的内存区域, 可能有其他临时加入的对象

#### 3.2.3 再谈引用

* JDK1.2后堆引用的扩充:
  * 强引用: 最传统的引用, 普遍存在的引用赋值. 强引用关系存在, 垃圾收集器一定不会回收被引用的对象
  * 软引用: 用来描述一些还有用, 但非必须的对象. 在内存溢出异常前, 会把这些对象进行二次回收, 如果这次内存还不够, 则抛出内存溢出的异常
  * 弱引用: 强度比软引用更弱, 被弱引用关联的对象只能生存到下一次垃圾收集发生
  * 虚引用: 最弱的引用, 不对垃圾收集和对象生存时间构成影响, 只是为了在这个对象被回收时收到系统通知

#### 3.2.4 生存还是死亡?

* 宣告对象死亡的两步: ①可达性分析后发现没有与 GC Roots 相连的引用链, 第一次标记. ②筛选是否需要执行 finalize()方法, 如果对象没有覆盖过 finalize()方法或者 finalize()方法已经被虚拟机调用过, 则不执行回收
* 注: finalize()方法只会被系统自动调用一次

#### 3.2.5 回收方法区

* 方法区回收的两部分内容:
  * 废弃的常量
  * 不再使用的类型

### 3.3 垃圾收集算法

#### 3.3.1分代收集理论

* 分代收集理论建立在两个分代假说之上:
  * 弱分代假说: 绝大多数对象都是朝生夕灭的
  * 强分代假说: 熬过越多次垃圾收集过程的对象就越难消亡
* 第三个假说跨代引用假说: 跨代引用相对于同代引用来说仅占极少数.该假说为两个分代假说的隐含结论
* 在新生代上简历全局数据结构记忆集, 把老年带分成若干小块, 标识出存在跨代引用的老年带, 发生 MinorGC 时只有包含了跨代引用的内存的对象才会被加入到 GC Root
* 收集的类型
  1. 部分收集(Partial GC)
     1. 新生代收集(Minor GC/Young GC)
     2. 老年带收集(Major GC/Old GC)
     3. 混合收集(Mixed GC)
  2. 整堆收集(Full GC)

#### 3.3.2 标记-清除算法

* 最基础的收集算法, 缺点: ①执行效率不稳定, 若 Java 堆中有大量需要回收的对象,则需要进行大量的标记和清除动作②会产生大量不连续的内存碎片

#### 3.3.3 标记-复制算法

* 为了解决标记-清除算法 **执行效率低** 的问题
* 半区复制
  * 将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块, 使用的这块用完之后, 将还存获得对象复制到另一块上
  * 缺点: 对于大量存活对象的情况, 会产生大量复制开销, 且可用内存缩小了一半
* Appel 式回收
  * 把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间, 每次分配内存只使用 Eden 和一块 Survivor, 发生垃圾收集时, 将 Eden 和 Survivor 中仍存活的对象复制到另一块 Survivor 上, 再清理 Eden 和用过的 Survivor
  * HotSpot 默认 Eden 和 Survivor 大小比例是8:1
  * 当 Survivor 不够存放存活对象时, 需要依赖其他区域(大多数是老年代)进行分配担保

#### 3.3.4 标记-整理算法

* 针对老年代对象的存亡特征提出的标记-整理算法, 让存活的对象向内存空间一端移动, 然后清理掉边界以外的内存
* 移动对象内存回收时会更复杂, 但是吞吐量大; 不移动对象内存分配时会更复杂, 但停顿时间短, 甚至不需要停顿, 延迟低

### 3.4 HotSpot 的算法细节实现

#### 3.4.1 根节点枚举

* 迄今为止, 所有收集器的根节点枚举必须暂停拥护线程, 保证分析过程中根节点集合的对象引用关系不发生变化
* HotSpot 中使用一组成为 OopMap 的数据结构来记录哪些地方存在对象引用, 而不需要一个不漏地从方法区等 GC Roots 开始查找

#### 3.4.2 安全点

* 如果为每一条指令都生成对应的 OopMap, 则会需要大量的额外存储空间. 因此只在"特定的位置"记录了这些信息, 这些位置被称为 **安全点**. 用户程序执行时被强制要求必须到达安全点后才能够暂停
* 安全点位置的选取基本上以 **是否具有让程序长时间执行的特征** 为标准选定的. 这个长时间执行最明显的特征是指令序列的复用, 如方法跳转, 循环跳转, 异常跳转等(因为每条指令执行的时间都非常短暂, 因此不会因为指令流程长度太长的原因长时间执行)
* 如何再垃圾收集发生时让所有线程都跑到安全点:
  * 抢先式中断: 垃圾收集发生时系统强制中断所有拥护线程, 如果发现有拥护线程中断的地方不在安全点, 就恢复这条线程执行, 让它一会再中断, 直到跑到安全点. **使用少**
  * 主动式中断: 垃圾收集发生时系统仅仅简单地设置一个标志位, 各个线程执行过程中不断轮询标志位, 一旦发现需要中断时就在离自己最近的安全点上主动中断挂起. 

#### 3.4.3 安全区域

* 为了解决程序不执行时(Sleep 或 Blocked状态下, 无法响应中断请求, 不能走到安全的地方中断挂起)的中断问题, 引入安全区域
* 安全区域指能够确保某一段代码片段中引用关系不会发生变化, 在这个区域任意地方开始垃圾收集都是安全的
* 进入安全区域的线程会标识自己进入了安全区域, 虚拟机发起垃圾收集时就可以不管已声明在安全区域内的线程. 若要离开安全区域时根节点枚举未结束则会等待到根节点枚举结束

#### 3.4.5 记忆集与卡表

* 所有涉及部分区域收集行为的垃圾收集器都可能面临跨代引用问题
* 记忆集是一种 **用于记录从非收集区指向收集区域的指针集合的抽象数据结构**. 

* 垃圾收集的场景中, 收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针, 不需要了解跨代引用的全部细节, 因此可以选择相对(用非收集区**所有**含跨代引用的**对象数组**实现)更粗犷的记录粒度来节省记忆集的存储和维护成本:
  * 字节精度: 每个记录精确到一个机器字长(即处理器的寻址位数), 该字包含跨代指针
  * 对象精度: 每个记录精确到一个对象, 该对象里有字段包含跨代指针
  * 卡精度: 每个记录精确到一块内存区域, 该区域内有对象含有跨代指针. 被称为卡表方式, 是最常用的记忆集实现形式
* 卡表最简单的形式可以是一个字节数组, 其中每个元素都对硬着其标识的内存区域中一块特定大小的内存块, 被称作"卡页". 一个卡页的内存中通常包含不止一个对象, 只要卡页内有一个及以上的对象字段存在跨代指针, 就将对应卡表的数组元素标识为1, 没有则标识为0. 垃圾收集发生时, 将标识为1的元素加入 GC Roots 一并扫描

#### 3.4.5 写屏障

* 必须找到一个在机器码层面的手段, 把维护卡表的动作放到每一个赋值操作之中. HotSpot 中使用 **写屏障** 实现
* 写屏障可以看作是引用对象赋值动作的 AOP 切面, 会产生一个环形通知, 供程序执行额外的操作. (增加更新卡表操作, 一般用于写后屏障)
* 伪共享: 不同卡表元素对应的内存区域可能位于同一个缓存行中, 不同现车给你同时更新时会影响性能. 解决方案是不采用无条件的写屏障, 先检查卡表标记, 只有当该卡表元素未被标记过才将其标记.

#### 3.4.6 并发的可达性分析

* 并发时可能出现的不好情况: 把原本消亡的对象标记为存活/把原本存活的对象标记为消亡
* 为了解决以上的情况, 有两种解决方案
  1. 增量更新: 以扫描完成的对象插入新的指向未扫描对象的引用关系时, 将这个新插入记录下来, 等并发扫描结束后, 再将记录过的引用关系的对象作为扫描根进行扫描
  2. 原始快照: 当扫描过(但未扫描完)的对象要删除指向未扫描对象的引用关系时, 将这个要删除的引用记录下来, 并发扫描结束后, 将记录过的引用关系的对象作为扫描根, 重新扫描一次

### 3.5 经典垃圾收集器

#### 3.5.1 Serial 收集器

* 单线程工作, 即垃圾收集时必须暂停其他所有工作线程, 新生代标记-复制, 老年代标记-整理
* HotSpot 运行在客户端模式的默认新生代收集器, 简单而高效(相对其他收集器的单线程)

#### 3.5.2 ParNew 收集器

* Serial 收集器的多线程并行版本
* 除了 Serial 收集器外只有 ParNew 收集器能和 CMS 收集器配合工作

#### 3.5.3 Parallel Scavenge 收集器

* 新生代收集器, 基于标记-复制算法
* 关注点和其他收集器不同, 达到可控制的吞吐量
* -XX: MaxGCPauseMillis 参数设置最大垃圾收集停顿时间(尽量满足), 停顿时间下降会导致吞吐量下降
* -XX: GCTimeRatio 参数设置垃圾垃圾收集时间占总时间比例的倒数, 默认99-> 占比允许1%的垃圾收集时间
* -XX: UseAdaptiveSizePolicy, 激活后就不需要人工指定新生代大小(-Xmn), Eden 与 Survivor 区的比例(-XX: SurvivorRatio), 晋升老年代对象的大小(-XX: PretenureSizeThreshold)等细节参数, 被称为垃圾收集的自适应调节策略. 使用该策略时只需要基本的内存数据设置好, 如-Xmx 最大堆, -XX: MaxGCPauseMillis(更关注停顿时间) 或-XX: GCTimeRatio(更关注吞吐量)

#### 3.5.4 Serial Old 收集器

* Serial 收集器的老年代版本, 使用标记-整理算法
* 服务端模式下的两种用途:
  * JDK5及之前, 与 Parallel Scavenge 收集器搭配使用
  * 作为 CMS 收集器发生失败时的后背元

#### 3.5.5 Parallel Old 收集器

* 是 Parallel Scavenge 收集器的老年代岸本, 基于标记整理算法
* 和 Parallel Scavenge 收集器搭配成为吞吐量优先的收集器组合

#### 3.5.6 CMS 收集器

* 关注**最短回收停顿时间**, 主要用于 B/S 系统的服务端, 基于标记-清除
* 初始标记-并发标记-重新标记-并发清除
  * 初始标记: 仅标记GC Roots能直接关联到的对象, 需暂停所有用户线程
  * 并发标记: 从初始标记对象开始遍历所有对象, 不需要暂停用户线程
  * 重新标记: 修正并发标记期间变动的对象, 需要暂停所有用户线程
  * 并发清除, 可与用户线程并发
* 三个缺点:
  1. 对处理器资源非常敏感, 当处理器核心不足四个时, CMS对用户程序的影响可能变大. 一种优化方案: 增量式并发收集器, 在并发标记和并发清理的时候让垃圾收集线程和用户线程交替运行, 结果是速度变慢的时见多了但是速度变慢的幅度小了
  2. 无法收集浮动垃圾, 可能出现Con-current Mode Failure导致暂停用户线程的Full GC. (浮动垃圾: 并发标记和并发清理阶段用户线程运行时产生的垃圾). 因为需要用户线程并发, 因此还需要预留一部分老年代空间给用户线程
  3. 因为基于标记-清除, 因此可能产生很多的空间碎片

#### 3.5.7 Garbage First 收集器

* G1收集器, 开创了面向局部收集的设计思路和基于Region的内存布局形式.
* Mixed GC模式: 不再单纯回收老年代/新生代/整个Java堆, 而是根据哪块内存中垃圾最多, 回收收益最大来进行回收
* 把Java堆划分成多个大小相等的独立区域(Region), 每个Region都可以根据需要扮演新生代的Eden空间或Survivor空间或是老年代空间, 将Region作为垃圾回收的最小单元, 优先回收价值高的Region
* 需要解决的问题
  * 跨Region引用: 记忆集
  * 收集线程和用户线程互不影响: 采用原始快照的方式. 除此之外, 每个Region还维护两个名为TAMS的指针, 在并发回收过程中新分配的对象地址都应该在这两个指针之上
  * 建立可靠的停顿预测模型: 以衰减均值为理论基础来实现, 能更准确的代表**最近**的平均状态
* 流程: 
  * 初始标记: 仅标记GC Roots直接关联的对象, 修改TAMS保证并发过程中可以正确分配新对象
  * 并发标记: 进行可达性分析
  * 最终标记: 短暂暂停用户线程, 用于处理并发标记阶段遗留下来的少量SATB记录
  * 筛选回收: 对各个Region进行排序, 根据用户期望的停顿时间制定回收计划, 必须暂停用户线程
* 从整体看, 基于标记-整理算法, 根据用户设定的**期望停顿时间**在不同场景下获得关注吞吐量和关注延迟之间的平衡
* 相比于CMS的缺点:
  * 由于卡表实现更为复杂, 且每个Region无论是新生代还是老年代, 都需要一份卡表, 导致**内存占用**高
  * CMS的写后屏障是直接的同步操作, G1的写后屏障类似于消息队列, 再做异步处理, 因此执行负载较高

### 3.6 低延迟垃圾收集器

* 内存的扩大对垃圾收集器的延迟会带来负面影响
* Shenandoah和ZGC几乎整个工作过程全部都是并发的

#### 3.6.1 Shenandoah收集器

* 和G1有相似的堆内存布局, 多阶段的处理思路上高度一致
* 与G1的不同:
  * G1回收阶段可以多线程并行, 但是不能与用户线程并发, Shenandoah收集器可以
  * Shenandoah目前默认不使用分代收集
  * Shenandoah摒弃了记忆集, 改用名为**连接矩阵**的数据结构来记录跨Region的引用关系
* 工作过程中的九个阶段
  * 初始标记: 标记和GC Roots直接关联的对象
  * **并发标记**: 遍历对象图, 标记出全部可达对象
  * 最终标记: 处理剩余的SATB扫描, 统计回收价值最高的Region, 构成回收集. 该阶段会有一小段短暂的停顿
  * 并发清理: 清理整个区域内一个存活对象都没有找到的Region
  * **并发回收**: 把要回收集里的存活对象复制一份到其他未被使用的Region中, 通过读屏障和"Brook Pointers"(转发指针)来实现
  * 初始引用更新: 建立线程集合点, 确保并发回收的线程已完成对象移动, 会有短暂的停顿
  * **并发引用更新**: 把堆中指向旧对象的引用修正到复制后的新地址. 按照内存物理地址顺序, 线性搜索出引用类型, 修改值
  * 最终引用更新: 修改存在于GC Roots中的引用, 是最后一次停顿
  * 并发清理: 清理回收集中剩下的Region
* 转发指针
  * 原有的实现对象移动与用户程序并发的方案是设置**保护陷阱**, 一旦用户程序访问到属于旧对象原有的内存旧自毁中断, 再在预设号的异常处理器中将访问呢转发到新对象上.
  * 在原有对象布局结构的最前面统一增加一个新的引用字段, 在正常不处于并发移动的情况下, 该引用指向对象自己
  * 必须对转发指针的操作采取同步措施, 让收集器线程或用户线程对转发指针的访问只有一个能成功. 通过比较并交换(CAS)操作来保证并发时对象的访问正确性
* 在读写屏障中都加入了额外的转发处理

#### 3.6.2 ZGC收集器

* 基于Region的堆内存布局, (暂时)不设分代, Region具有动态性: 动态创建和销毁, 动态的区域容量大小
* Region的三种容量
  * 小型Region: 2MB, 放置小于256KB的小对象
  * 中型Region: 32MB, 放置大于等于256KB但小于4MB的对象
  * 大型Region: 容量不固定, 必须是2MB的整倍数, 用于放置4MB以上的对象. **每个大型Region只会存放一个大对象**
* 并发整理算法的实现通过染色指针
* 染色指针是一种直接将少量额外的信息存储在指针上的技术(linux系统下46位指针的高4位)
* 染色指针优点: 
  * 一旦某个Region的存活对象被移走之后, 这个Region立即被释放和重用, 不需要等待整个堆中所有指向该Region的引用都被修正
  * 大幅减少在垃圾收集过程中内存屏障的是用数量
  * 可作为一种可扩展的存储结构用来记录更多与对象标记, 重定位过程相关的数据
* 四个阶段:
  * 并发标记: 遍历对象图做可达性分析
  * 并发预备重分配: 根据特定的查询条件统计得出本次收集过程要清理的Region, 组成重分配集
  * **并发重分配**: 把重分配集中的存活对象复制到新的Region上, 并为重分配集中的每个Region维护一个转发表. 记录旧对象到新对象的转向关系. 由于染色指针的支持, 收集器能仅从引用上就明确得知一个对象是否处于重分配集中, 因此如果用户线程访问了位于重分配集中的对象, 会被内存屏障截获, 然后转发到新的对象上, 同时修正引用的值.
  * 并发重映射: 修正整个堆中指向重分配集中旧对象的锁有引用, 因为旧引用可以自愈, 所以这个阶段的工作合并到了下一次垃圾收集循环中的并发标记阶段

### 3.7 选择合适的垃圾收集器

#### 3.7.1 Epslion收集器

* 不进行垃圾收集: 面向运行数分钟甚至数秒的应用, 只要Java虚拟机能够正确分配内存, 在堆耗尽之前就会退出

#### 3.7.2 收集器的权衡

* 应用程序的关注点:
  * 数据分析/科学计算类的任务, 目标时快速出结果, 应该关注吞吐量
  * SLA应用, 关注延迟/停顿时间
  * 客户端或嵌入式应用, 关注垃圾收集的内存占用
* 运行应用的基础设施
* 使用JDK 的发行商, 版本号

#### 3.7.3 虚拟机及垃圾收集器日志

### 3.8 实战: 内存分配与回收策略

#### 3.8.1 对象优先在Eden分配

* 大多数情况下, 对象在新生代Eden区中分配. 当Eden区中没有足够空间进行分配时, 虚拟机将发起Minor GC, 通过分配担保机制将之前新生代中的对象转移到老年代

#### 3.8.2 大对象直接进入老年代

* Java虚拟机中要避免大对象是因为在分配空间时容易导致因没有**连续**内存空间而引发的垃圾收集
* -XX: PretenureSizeThreshold参数制定大与该设置值的对象直接在老年代分配, 避免在Eden区及两个Survivor区之间来回复制

#### 3.8.3 长期存活的对象将进入老年代

* 经过第一次MinorGC后仍然存活且能被Survivor容纳的对象会被移动到Survivor空间中, 且每熬过一次MinorGC, 年龄就增加1岁, 达到阈值后晋升到老年代(默认15). 通过参数-XX: MaxTenuringThresshold设置阈值

#### 3.8.4 动态对象年龄判定

* Survivor空间中相同年龄所有对象大小总和大与Survivor空间的一半, 年龄大于或等于该对象的年龄可以直接进入老年代

#### 3.8.5 空间分配担保

* MinorGC之前, 检查老年代最大可用的连续空间是否大与新生代所有对象总空间, 成立则这次MinorGC确保是安全的(当Survivor中无法容纳新生代的存活对象时, 需要老年代进行分配担保). 分配担保的前提是**老年代能容纳这些对象**. 
* 如果不能确保MinorGC是安全的, 则检查-XX: HandlePromotionFailure参数设置是否允许担保失败. 如果允许会继续检查老年代最大可用的连续空间是否大与历次晋升到老年代对象的平均大小, 如果大于则尝试进行MinorGC, 如果小于或不允许冒险, 则需要进行FullGC

## 4 虚拟机性能监控, 故障处理工具

### 4.1 概述

* 处理数据: 异常堆栈, 虚拟机运行日志, 垃圾收集器日志, 线程快照(threaddump/javacore文件), 堆转储快照(heapdump/hprof文件)等

### 4.2 基础故障处理工具

#### 4.2.1 jps: 虚拟机进程状况工具

* JVM Process Status Tool, 列出正在运行的虚拟机进程及其本地虚拟机唯一ID(**LVMID**, Local Virtual Machine Identifier)

#### 4.2.2 jstat: 虚拟机统计信息监视工具

* JVM Statistics Monitoring Tool, 用于监视虚拟机各种运行状态信息的工具
* `jstat -gc 2764 250 20`每隔250ms查询一次进程2764的垃圾收集情况, 一共查询20次
* `jstat -gcutil 2764` 

#### 4.2.3 jinfo: Java配置信息工具

* 实时查看和调整虚拟机各项参数

## 5 调优案例分析与实战

### 5.2 案例分析

#### 5.2.1 大内存硬件上的程序部署策略

* 单个Java虚拟机实例管理大内存可能面临的问题:
  * 回收大块堆内存而导致的长时间停顿. G1有所环节, ZGC和Shenandoah成熟之后能解决
  * 大内存必须有64位Java虚拟机的支持, 由于指针压缩, 处理器缓存行等问题, 性能普遍低于同版本32位虚拟机
  * 必须保证应用程序足够问题, 否则大型单体应用发生堆内存溢出难以分析
  * 相同程序在64位虚拟机中消耗的内存一般比32位虚拟机大, 可以通过压缩指针环节
* 同时使用若干个虚拟机建立逻辑机群来利用硬件资源, 目的仅仅是尽可能利用硬件资源, 不需要保证每个虚拟机进程有绝对的负载均衡, 因此试用无Session复制的亲和式机群是相当合适的. 可能存在的问题:
  * 节点竞争全局资源
  * 很难高效率地利用某些资源池, 因为各个节点一般都建立子集独立的资源池
  * 大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费

#### 5.2.2 集群间同步导致的内存溢出

#### 5.2.3 堆外内存导致的溢出错误

* Direct Memory耗用的内存不计算在堆之内, 如果虚拟机打开了-XX: +DisableExplicitGC开关, 禁止了人工出发垃圾收集, 就会导致堆中还有空闲内存却不得不抛出内存溢出异常

* 小内存会32位应用时, 除了Java堆和方法区外, 还应该关注:

  1. 直接内存: 通过-XX: MaxDirectMemorySize调整大小, 不足时抛出OutOf-MemoryError或OutOfMemoryError: Direct buffer memory
  2. 线程堆栈: 通过-Xss调整大小, 内存不足时抛出StackOerflowError或OutOfMemoryError
  3. Socket缓存区: 每个Socket链接都有Receive和Send两个缓存区, 链接多的话也可能出问题, 抛出IOException: Too many open files
  4. JNI代码
  5. 虚拟机和垃圾收集器

  这些内存和Java堆以及方法区**总和**受到操作系统进程最大内存的限制

#### 5.2.4 外部命令导致系统缓慢

#### 5.2.5 服务器虚拟机进程崩溃

#### 5.2.6 不恰当的数据结构导致内存占用过大

#### 5.2.7 由Windows虚拟内存导致的长时间停顿

#### 5.2.8 由安全点导致长时间停顿

# 三 虚拟机执行子系统

## 6 类文件结构

### 6.2 无关性的基石

* 字节码文件

### 6.3 Class类文件的结构

* 任何一个class文件都对应着唯一的一个类或接口的定义信息, 但是类或接口不一定都得定义在文件里, 也可以动态生成
* Class文件格式采用一种类似于C语言结构体的伪结构来存储数据, 这种伪结构只有两种数据结构:
  * 无符号数: 以u1, u2, u4, u8分别代表1个字节, 2个字节, 4个字节和8个字节的无符号数
  * 表: 多个无符号数或者其他表作为数据项构成的复合数据类型
* 需要描述同一类型但数量不定的多个数据时, 会使用一个前置的容量计数器加若干个连续的数据向的形式, 称为集合

#### 6.3.1 魔数与Class文件的版本

* 每个Class文件的头4个字节, 唯一作用是确定这个文件是否是一个能被虚拟机接受的Class文件. (0xCAFEBABE)
* 接下来4个字节存储的是Class文件的版本号, 前两个字节是次版本号, 后两个字节是主版本号

#### 6.3.2 常量池

* 紧接着版本号的是常量池入口, 放置一项u2类型的数据, 代表常量池容量计数器(constant_pool_count), **从1开始**不是从0开始(值为20代表常量池中有19项常量, 索引范围1-19), 0索引的作用是表达后面某些指向常量池的索引值的数据在特定情况下表示**不引用任何一个常量池项目**

* 常量池中存放的两大类常量: 

  * 字面量: 文本字符串, 被声明为final的常量值等

  * 符号引用: 编译原理方面的概念, 主要包括

    1. 被模块导出或开放的包
    2. 类和接口的全限定名
    3. 字段的名称和描述符
    4. 方法的名称和描述符
    5. 方法句柄和方法类型

    Javac编译时在虚拟机家在Class文件时进行动态连接, 因此Class文件中不会保存各个方法, 字段最终在内存中的布局. 虚拟机做类加载时, 会从常量池获得对应的符号引用, 再在类创建时或运行时解析, 翻译到具体的内存地址中

* 常量池中每一项常量都是一个表(共17项), 每个表结构起始的第一位是一个u1类型的标志位, 标志当前常量类型, 第二位是u2类型的name_index时常量池的索引值, 指向代表这个类(或者接口的)全限定名

* javap工具: `javap -verbose TestClass`可以输出TestClass.class文件字节码内容

#### 6.3.3 访问标志

* 常量池结束之后, 紧接着的2个字节代表访问标志, 用于识别一些类或者接口层次的访问信息: Class是类还是接口, 是否public, 是否abstract, 是否final. 这个值是由"是"标志含义的标志值的位或运算获得的.

#### 6.3.4 类索引, 父类索引与接口索引集合

* 访问标志之后是类索引, 父类索引和接口索引集合
* 类索引和父类索引是一个u2类型的数据, 接口索引集合是一组u2类型的时局的集合
* 类索引确定类的全限定名, 父类索引确定父类的全限定名, 接口索引集合中按implements关键字之后的接口顺序排列被实现的接口
* 类索引和父类索引用两个u2类型的索引表示, 指向一个类型位CONSTANT_Class_info的类描述符常量, 通过这个常量找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串
* 接口索引集合入口是u2类型的接口技术其, 代表索引表的容量

#### 6.3.5 字段表集合

* 用于描述接口或类中声明的变量, **不包含方法内部声明的局部变量**. 访问标志, 名称索引, 描述符索引

* 描述字段的信息: 

  * 标志位表示: 作用域(public等), static, final, olatile, transient,
  * 引用常量池常量描述: 数据类型, 字段名称

  1. 字段修饰符与类的访问修饰符(6.3.3)类似
  2. name_index(简单名称)和descriptor_index(描述符)都是对常量池项的引用
     1. 简单名称: 没有类型和参数修饰的方法或字段名称: inc()方法简单名为inc
     2. 全限定名: org/fenixsoft/clazz/Testlass
     3. 描述符: 用来描述字段的数据类型, 方法的参数列表和返回值. 按照先参数列表, 后返回值的顺序描述. java.lang.String\[]\[]的描述符为`[[Ljava/lang/String`, int[]描述符`[I`, void inc()描述符为`()V`, java.lang.String.toString()的描述符为`()Ljava/lang/String;`, `int indexOf(char[] source, in sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)`的描述符为`([CII[CIII])I`
  
* 字段表集合中不会出现从父类或者父接口中结成的字段

#### 6.3.6 方法表集合

* 方法表描述方式和字段表类似: 访问标志, 名称索引, 描述符索引, 属性表集合
* 方法中的java代码靖边编译器编译成字节码指令之后, 存放在方法属性表集合中一个名为"Code"的属性里面
* 方法表集合中不会出现来自父类且未被重写的方法

#### 6.3.7 属性表集合

* Class文件, 字段表, 方法表都可以携带子集的属性表集合
* 一个符合规则的属性表应该包含attribute_name_index(指向常量池中的常量), attribute_length, info

1. Code属性
   * 方法体里的代码编译的字节码指令, 接口或抽象类中的方法不存在Code属性. Class文件中**最重要**的一个属性
   * 结构
     * attribute_name_index指向CONSTANT_Utf8_info型常量的索引, 常量值固定为"Code"
     * attribute_length指示属性值的长度. 属性之的长度固定为整个属性表长度减去6个字节(属性名称索引和属性长度一共6个字节)
     * max_stack代表操作数栈深度的最大值. 方法执行的任意时刻, 操作数栈都不会超过这个深度
     * max_locals代表局部变量表所需的存储空间, 单位是变量槽(Slot). 长度不超过32位的数据类型每个变量占用一个变量槽, 64位的数据类型占用两个变量槽. 局部变量表的变量槽是可重用的,根据同时生存的最大局部变量和类型计算
     * code_length代表字节码长度
     * code是存储字节码指令的一系列字节流, 一个字节码就是一个u1类型的单字节(一条指令). u1类型取之范围对应0~255, 也就是可以表达最多256条指令
     * exception_table_length, exception_table, 显式异常处理表, 非必须
   * 非静态方法的局部变量表中至少会存在一个指向当前对象实例的局部变量, 局部变量表也会预留第一个变量槽来存放该引用
2. Exceptions属性
   * 作用是列举出方法中可能抛出的受查异常, 即throws关键字后列举的异常
3. LineNumberTable属性
   * 用于描述Java源码行号与字节码行号之间的对应关系, 非必须, 可以在Javac中试用-g: none或者-g: lines设置取消或生成这项信息, 取消产生的影响就是抛出异常使堆栈中不会显示出错的行号且调试程序时无法按照源码行来设置断点
4. LocalVariableTable及LocalVariableTypeTable属性
5. SourceFile及SourceDebugExtension属性

...

### 6.4 字节码指令简介

* Java虚拟机采用面向操作数栈的架构, 所以大多数指令都不包含操作数, 只有一个码, 指令参数都存放在操作数栈中
* Java虚拟机限制操作码长度位1个字节, 意味指令集的操作码总数不能够超过256条
* Class文件格式放弃了编译后代码的操作数长度对齐, 因此在操作一些1字节以上的操作数时会损失一些性能, 但是能声调大量的填充和间隔符号

#### 6.4.1 字节码与数据类型

* 指令集中大多数指令都包含其操作所对应的数据类型信息. 由于字节码长度限制, 对于特定的操作只提供了有限的类型相关指令支持
* 编译器会在编译或运行期间将byte和short类型的数据大夫号扩展位相应的int型数据, 将boolean和char类型数据零位扩展位相应的int型数据

#### 6.4.2 加载和存储指令

* 将局部变量加载到操作栈: iload, iload_<n>等
* 将一个数值从操作数栈存储到局部变量表: istore, istore_<n>等
* 将一个常量加载到操作数栈: bipush, iconst_m1, iconst<i>等

#### 6.4.3 运算指令

* 对两个操作数栈上的值进行特定运算, 并把结果重新存入到操作栈顶
* 无论那种算术指令, 都是试用Java虚拟机的算术类型来进行计算的

#### 6.4.4 类型转换指令

* 直接支持(无须显式转换)的宽化类型转换: 
  * int -> long, float, double
  * long -> float, double
  * float -> double
* 窄化类型转换必须显式地使用转换指令. 
* 整数类型窄化转换时仅仅是丢弃除最低位N字节意外的内容, 可能导致正负号不同. 
* 浮点数值窄化转换时, 如果值是NaN, 结果是0; 否则向零舍入模式

#### 6.4.5 对象创建与访问指令

* 对类实例和数组的创建与操作使用了不同的字节码指令

#### 6.4.6  操作数栈管理指令

* 出栈, 复制栈顶元素并压栈, 栈顶元素互换

#### 6.4.7 控制转移指令

* 可以理解为有条件或无条件地修改PC寄存器的值
  * 条件分支
  * 复合条件分支
  * 无条件分支
* 所有类型的比较最后都会转换为int类型的比较操作

#### 6.4.8 方法调用和返回指令

* 方法调用指令与数据类型无关, 但是方法返回指令是根据返回值的类型区分的

#### 6.4.9 异常处理指令

#### 6.4.10 同步指令

* Java虚拟机支持方法级的同步和方法内部一段指令序列的同步
  * 方法级的同步是隐式的, 无须通过字节码指令来控制, 要求先持有管程
  * 虚拟机指令集中monitorenter和monitorexit两条指令支持synchronized关键字同步一段指令序列

### 6.5 公有设计, 私有实现

* 公有设计: 优化后的Class文件依然可以被正确读取, 包含其中的语义能保持完整
* 私有实现: 是先哲选择自己的方式实现语义, 进行优化
* 虚拟机实现的方式主要有两种: 
  * 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集
  * 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集(即时编译器代码生成技术)

### 6.6 Class文件结构的发展

## 7 虚拟机类加载机制

* 代码编译的结果: 本地机器码 -> 字节码

### 7.1 概述

* 在Java中类型的加载, 连接和初始化过程都是在程序运行期间完成的. 即**运行时动态加载和动态连接**

### 7.2 类加载的时机

* 一个类型从加载到虚拟机内存到卸载出内存, 经历七个阶段: 加载, 验证, 准备, 解析, 初始化, 使用, 卸载. 其中验证, 准备, 解析阶段统称为**连接**
* **解析**阶段在某些情况下可以在初始化阶段之后开始, 是为了支持Java的动态绑定
* **主动引用**: 虚拟机规范严格规定了**有且只有**六种情况必须立即对类进行初始化
  1. 遇到new, getstatic, putstatic或invokestatic四条字节码指令且类型还没有进行过初始化
  2. 使用java.lang.reflect包的方法对类型进行反射调用且类型还没有进行过初始化
  3. 当初始化类的时候若父类还没有初始化则先触发父类的初始化
  4. 虚拟机启动时, 回先初始化用户制定的主类(main)
  5. java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newInvokeSpecial的方法句柄, 且句柄对应的类没有初始化
  6. 被default关键字修饰的接口方法的实现类发生了初始化, 这个接口要先初始化
* 被动引用: 除主动引用外的引用, 都不会触发初始化
  * 通过字类引用父类的静态字段, 不会引发初始化
  * 通过数组定义来引用类, 不会引发初始化
  * 常量在编译阶段回存入调用类的常量池中, 本质上没有直接引用到定义常量的类, 因此不会出发定义常量的类的初始化

### 7.3 类加载的过程

#### 7.3.1 加载

* 加载阶段的工作:
  * 通过一个类的全限定名来获取定义此类的二进制字节流
    * 从ZIP压缩包中读取: JAR, EAR, WAR
    * 从网络中获取, Web Applet
    * 运行时计算生成, 动态代理的反射
    * 由其他文件生成: JSP
    * 从数据库读取: 中间件服务器
    * 从加密文件中读取
  * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  * 在内存中生成一个代表这个类的java.lang.Class对象
* 非数组类型既可以使用Java虚拟机里内置的引导类加载其来完成, 也可以用用户自定义的类加载器去完成(重写一个类加载器的findClass()或loadClass()方法)
* 数组类型
  * 元素类型: 数组去掉所有维度的类型; 组件类型: 数组曲调一个纬度的类型
  * 如果数组的组件类型是引用类型, 递归加载这个组件类型; 如果组件类型不是引用类型, Java虚拟机会把数组标记为与引导类加载器关联
  * 数组的可访问性与他的组件类型的可访问性一致. 如果组件类型不是引用类型, 那么数组类的可访问性默认为public

#### 7.3.2 验证

* 目的: 确保Class文件的字节流中包含的信息符合规范的全部约束要求
* 由于Class文件并不一定只能由Java源码编译而来, 因此Java的"相对安全"并不能被完全信任呢
* 四个检查动作:
  1. 文件格式验证
     * 魔数开头是否正确; 主次版本号是否在Java虚拟机接受范围之内; 常量池的常量中是否有不被支持的常量类型(检查常量tag标志); 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量; CONSTANT_Utf8_inf型的常量中是否有不符合UTF-8编码的数据; Class文件中各个部分及文件本身是否有被删除的或附加的其他信息**等等**
     * 只有这个阶段是基于**二进制字节流**进行的, 其他阶段是基于**方法区的存储结构**进行的
  2. 元数据验证
     * 对字节码描述的信息进行**语义**分析, 以保证其描述的信息符合规范的要求
       * 是否有父类
       * 是否继承了不允许被继承的类
       * 非抽象类是否实现了父类或接口中要求实现的所有方法
       * 类中的字段, 方法是否与父类产生矛盾
  3. 字节码验证
     * 通过数据流分析和控制流分析确定程序语义是合法的, 符合逻辑的.
     * 对**类的方法体**进行校验分析
     * 如果方法体的字节码没有通过字节码验证, 那肯定是有问题的; 如果一个方法体通过了字节码验证, 也不能保证它一定是安全的
  4. 符号引用验证
     * 该类是否缺少或被禁止访问他依赖的某些外部类, 方法, 字段等资源
       * 符号引用中通过字符串描述的全限定名能否找到对应的类
       * 在制定类中是否存在符合方法描述的字段描述符及简单名称所描述的方法和字段
       * 符号引用中的类, 字段, 方法的可访问性是否可被当前类所访问

#### 7.3.3 准备

* 正式为类中定义的变量(静态变量)分配内存并设置变量初始值(通常是数据类型的**零值**, 不是赋的值. 特殊情况: 类字段的字段属性表中存在ConstantValue属性, 就会被赋值, 也就是常量赋值), 在方法区(逻辑概念)
* 进行内存分配的仅包括**类变量**, 不包括实例变量.

#### 7.3.4 解析

* Java虚拟机将常量池中的符号引用替换为直接引用

  * 符号引用: 以一组符号来描述所引用的目标, 与虚拟机时显得内存布局无关, 引用的目标不一定是已经加载到虚拟机内存当中的目标
  * 直接引用: 直接指向目标的指针, 相对便宜两或者是能间接定位到目标的句柄, 和虚拟机实现的内存布局直接相关, 引用的目标必定已经加载到虚拟机内存中

* 对同一个符号引用进行多次解析请求使用的是第一次解析的结果缓存(除invokedynamic指令外)

* invokedynamic指令对应的引用成为"动态调用点限定符", 动态的含义是必须等到程序实际运行到这条指令时才开始解析

* 解析动作的主要类型

  1. 类或接口的解析,

     成功解析类D中的符号引用N为C后还需要进行符号引用验证, 确认D 是否具备对C的访问权限

  2. 字段解析

     * 会先对字段表内的class_index项中索引的CONSTANT_Class_info符号引用进行解析, 即获取到**字段所属的类或接口**的符号引用
     * 找到字段所属的类或接口C后再进行后续搜索:
       1. 如果C本身包含了简单名称和字段描述符都于目标相匹配的字段, 则返回字段的直接引用
       2. 否则如果C 中实现了接口, 则从下往上递归搜索各个接口和其父接口, 如果包含, 同1
       3. 否则, 如果C不是java.lang.Object的话, 按照继承关系从下往上搜索父类, 如果包含, 同1
     * 返回引用之后会对字段进行权限验证

  3. 方法解析

     * 和字段解析一样, 需要先解析出方法表的class_index索引的方法所属的类或接口的符号引用
     * 由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的, 所以如果在类的方法爱奥中发现索引是接口的话会直接抛出异常
     * 在类中继续查找是否有简单名称和描述符都和目标相匹配的方法, 如果有则返回方法的直接引用
     * 在类实现的接口列表及父接口之中递归查找, 如果有匹配的方法, 说明类是抽象类, 抛出异常
     * 否则查找失败
     * 最后若返回了直接引用, 则进行权限验证

  4. 接口方法解析

     * 解析出接口方法表的class_index项找到所属的类或接口的符号引用
     * 如果索引是类不是接口那么抛出异常
     * 在找到的接口中查找是否有简单名称和描述符都和目标相匹配的方法, 有则返回方法的直接引用
     * 否则在接口的父接口中递归查找, 直到java.lang.Object类为止, 看是否有匹配的方法, 返回直接引用
     * 否则宣告查找失败

#### 7.3.5 初始化

* 该阶段Java虚拟机真正开始执行类中编写的Java程序代码, 将主导权移交给应用程序
* 根据程序员通过程序编码制定的主观计划初始化变量和其他资源. 
* 初始化阶段就是执行类构造器**\<clinit>()**方法的过程
  * \<clinit>()方法时由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的. 静态语句块只能**访问**到定义在静态语句块之前的变量, 对于定义在其之后的变量, 只能**赋值**, 不能访问
  * Java虚拟机会保证在子类的\<clinit>()方法执行之前, 父类的\<clinit>()方法已经执行完毕. 因此第一个被执行\<clinit>()方法的类型肯定是java.lang.Object类. 因此父类中定义的静态语句块要**优先于**子类的变量赋值操作
  * \<clinit>()方法对于类或接口来说并不是必须的, 如果一个类中没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成\<clinit>()方法
  * 执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法, 只有当父接口中定义的变量被使用时, 父接口才会被初始化

### 7.4 类加载器

#### 7.4.1 类与类加载器

* 比较两个类是否相等, 只有在这两个类是由同一个类加载器加载的前提下才有意义